.\"
.\" Copyright (c) 2025 Ryan Moeller
.\"
.\" SPDX-License-Identifier: BSD-2-Clause
.\"
.Dd October 20, 2025
.Dt FETCH 3lua
.Os
.Sh NAME
.Nm get ,
.Nm put ,
.Nm xget ,
.Nm stat ,
.Nm list ,
.Nm request ,
.Nm ABORT ,
.Nm AUTH ,
.Nm DOWN ,
.Nm EXISTS ,
.Nm FULL ,
.Nm INFO ,
.Nm MEMORY ,
.Nm MOVED ,
.Nm NETWORK ,
.Nm OK ,
.Nm PROTO ,
.Nm RESOLV ,
.Nm SERVER ,
.Nm TEMP ,
.Nm TIMEOUT ,
.Nm UNAVAIL ,
.Nm UNKNOWN ,
.Nm URL
.Nd Lua bindings for
.Xr fetch 3
.Sh SYNOPSIS
.Bd -literal
fetch = require('fetch')
.Ed
.Pp
.Bl -tag -width XXXX -compact
.It Dv f, errmsg, errcode = fetch.get(url[ , flags ] )
.It Dv f, errmsg, errcode = fetch.put(url[ , flags ] )
.It Dv f, stat_or_errmsg, errcode = fetch.xget(url[ , flags ] )
.It Dv stat, errmsg, errcode = fetch.stat(url[ , flags ] )
.It Dv ents, errmsg, errcode = fetch.list(url[ , flags ] )
.It Dv f, errmsg, errcode = fetch.request(url, method[ , flags[ , content_type[ , body ] ] ] )
.It Dv f, stat_or_errmsg, res_headers_or_errcode, res_trailers = fetch.xrequest(url, method[ , flags[ , req_headers[ , req_trailers[ , res_headers[ , res_trailers[ , body ] ] ] ] ] )
.It Dv res_trailers = fetch.trailers(f )
.El
.Sh DESCRIPTION
The
.Nm fetch
module provides bindings for File Transfer Library
.Pq libfetch
function calls.
.Pp
Functions taking a
.Fa url
parameter accept either a string or a table with one of the following forms:
.Bd -literal -offset indent
{
	scheme = "",
	[ host = "", ]
	[ port = #, ]
	[ doc = "", ]
	[ user = "", ]
	[ pwd = "", ]
	[ offset = #, ]
	[ length = #, ]
	[ ims_time = #, ]
}

{
	url = "",
	[ offset = #, ]
	[ length = #, ]
	[ ims_time = #, ]
}
.Ed
.Pp
At least one of
.Va host
or
.Va doc
must be supplied in the first form.
Omitted strings default to
.Li ""
and omitted numbers
default to
.Li 0 .
.Bl -tag -width XXXX
.It Dv f, errmsg, errcode = fetch.get(url[ , flags ] )
Wraps fetchGet.
.It Dv f, errmsg, errcode = fetch.put(url[ , flags ] )
Wraps fetchPut.
.It Dv f, stat_or_errmsg, errcode = fetch.xget(url[ , flags ] )
Wraps fetchXGet.
.It Dv stat, errmsg, errcode = fetch.stat(url[ , flags ] )
Wraps fetchStat.
.It Dv ents, errmsg, errcode = fetch.list(url[ , flags ] )
Wraps fetchList.
.It Dv f, errmsg, errcode = fetch.request(url, method[ , flags[ , content_type[ , body ] ] ] )
Wraps fetchReqHTTP.
.It Dv f, stat_or_errmsg, res_headers_or_errcode, res_trailers = fetch.xrequest(url, method[ , flags[ , req_headers[ , req_trailers[ , res_headers[ , res_trailers[ , body ] ] ] ] ] )
Wraps fetchXReqHTTP.
.Pp
.Fa req_headers ,
.Fa req_trailers ,
.Fa res_headers ,
and
.Fa res_trailers
are tables constructed as a list of headers:
.Bd -literal -offset indent
{
	{
		name = "",
		value = ""|#,
	},
	...
}
.Ed
.Pp
.Fa req_trailers
may be appended to during the call to
.Fn fetch.xrequest
as a result of the
.Fa body
being read.
.Pp
.Fa res_headers
and
.Fa res_trailers
are passed through as return values,
and are modified in-place.
.Pp
.Fa res_trailers
is not filled until the response body in
.Va f
has been read completely and either closed or passed to
.Fn fetch.trailers .
.Pp
.Fa body
can be:
.Bl -bullet -compact
.It
.Dv nil
.It
a string
.It
a Lua file object
.It
a table with a
.Va read
method taking the number of bytes to read as a parameter and returning a string,
and optionally a
.Va seek
method taking a whence string and integer offset as parameters and returning the
new position as an integer.
.El
.Pp
A request
.Fa body
with a successful seek operation may be sent unchunked,
while an unseekable
.Fa body
will be chunked.
.It Dv res_trailers = fetch.trailers(f )
Returns the argument passed as
.Fa req_trailers
for the call to
.Fn fetch.xrequest
that produced
.Fa f ,
filling the table with any trailers following the response body if present and
not already done.
.Pp
This call always returns
.Dv nil
if
.Fa f
has been closed.
.El
.Sh EXAMPLES
Get the contents of a URL:
.Bd -literal -offset indent
fetch = require('fetch')

f = fetch.get('https://download.freebsd.org/ftp/TIMESTAMP')
timestamp = f:read('*a')
f:close()
print(timestamp)
.Ed
.Sh SEE ALSO
.Xr fetch 3
.Sh AUTHORS
.An Ryan Moeller
