.\"
.\" Copyright (c) 2025 Ryan Moeller
.\"
.\" SPDX-License-Identifier: BSD-2-Clause
.\"
.Dd December 5, 2025
.Dt ACL 3lua
.Os
.Sh NAME
.Nm acl
.Nd Lua bindings for
.Xr acl 3
Access Control List
.Pq ACL
manipulation routines in libc
.Sh SYNOPSIS
.Bd -literal
ACL = require('acl')
.Ed
.Pp
.Bl -tag -width XXXX -compact
.It Dv ok, errmsg, errcode = ACL.delete(file[ , type ] )
.It Dv ok, errmsg, errcode = ACL.delete_fd(fd[ , type ] )
.It Dv ok, errmsg, errcode = ACL.delete_file(path[ , type ] )
.It Dv ok, errmsg, errcode = ACL.delete_link(path[ , type ] )
.It Dv extended, errmsg, errcode = ACL.extended_file(path )
.It Dv extended, errmsg, errcode = ACL.extended_link(path )
.It Dv acl, errmsg, errcode = ACL.from_mode(mode )
.It Dv acl, errmsg, errcode = ACL.from_text(text )
.It Dv acl, errmsg, errcode = ACL.get(file[ , type ] )
.It Dv acl, errmsg, errcode = ACL.get_fd(fd[ , type ] )
.It Dv acl, errmsg, errcode = ACL.get_file(path[ , type ] )
.It Dv acl, errmsg, errcode = ACL.get_link(path[ , type ] )
.It Dv acl, errmsg, errcode = ACL.new([count ] )
.It Dv acl1 == acl2
.It Dv ok, errmsg, errcode = acl:calc_mask( )
.It Dv entry, errmsg, errcode = acl:create_entry([index ] )
.It Dv ok, errmsg, errcode = acl:delete_entry([entry | index ] )
.It Dv acl1, errmsg, errcode = acl:dup( )
.It Dv possible, mode_or_errmsg, errcode = acl:equiv_mode( )
.It Dv brand, errmsg, errcode = acl:get_brand( )
.It Dv entry, errmsg, errcode = acl:get_entry(id )
.It Dv trivial, errmsg, errcode = acl:is_trivial( )
.It Dv ok, errmsg, errcode = acl:set(file[ , type ] )
.It Dv ok, errmsg, errcode = acl:set_fd(fd[ , type ] )
.It Dv ok, errmsg, errcode = acl:set_file(path[ , type ] )
.It Dv ok, errmsg, errcode = acl:set_link(path[ , type ] )
.It Dv size, errmsg, errcode = acl:size( )
.It Dv acl1, errmsg, errcode = acl:strip(recalculate_mask )
.It Dv text, errmsg, errcode = acl:to_text([flags ] )
.It Dv valid, errmsg, errcode = acl:valid([file[ , type ] ] )
.It Dv valid, errmsg, errcode = acl:valid_fd(fd[ , type ] )
.It Dv valid, errmsg, errcode = acl:valid_file(path[ , type ] )
.It Dv valid, errmsg, errcode = acl:valid_link(path[ , type ] )
.It Dv ok, errmsg, errcode = entry:copy(src_entry )
.It Dv flagset, errmsg, errcode = entry:get_flagset( )
.It Dv permset, errmsg, errcode = entry:get_permset( )
.It Dv qualifier, errmsg, errcode = entry:get_qualifier( )
.It Dv tag_type, errmsg, errcode = entry:get_tag_type( )
.It Dv type, errmsg, errcode = entry:get_type( )
.It Dv ok, errmsg, errcode = entry:set_flagset(flagset )
.It Dv ok, errmsg, errcode = entry:set_permset(permset )
.It Dv ok, errmsg, errcode = entry:set_qualifier(qualifier )
.It Dv ok, errmsg, errcode = entry:set_tag_type(tag_type )
.It Dv ok, errmsg, errcode = entry:set_type(type )
.It Dv ok, errmsg, errcode = flagset:add(flag )
.It Dv ok, errmsg, errcode = flagset:clear( )
.It Dv ok, errmsg, errcode = flagset:delete(flag )
.It Dv set, errmsg, errcode = flagset:get(flag )
.It Dv ok, errmsg, errcode = permset:add(perm )
.It Dv ok, errmsg, errcode = permset:clear( )
.It Dv ok, errmsg, errcode = permset:delete(flag )
.It Dv set, errmsg, errcode = permset:get(perm )
.It Dv ACL.MAX_ENTRIES
.It Dv ACL.BRAND_UNKNOWN
.It Dv ACL.BRAND_POSIX
.It Dv ACL.BRAND_NFS4
.It Dv ACL.UNDEFINED_TAG
.It Dv ACL.USER_OBJ
.It Dv ACL.USER
.It Dv ACL.GROUP_OBJ
.It Dv ACL.GROUP
.It Dv ACL.MASK
.It Dv ACL.OTHER
.It Dv ACL.OTHER_OBJ
.It Dv ACL.EVERYONE
.It Dv ACL.ENTRY_TYPE_ALLOW
.It Dv ACL.ENTRY_TYPE_DENY
.It Dv ACL.ENTRY_TYPE_AUDIT
.It Dv ACL.ENTRY_TYPE_ALARM
.It Dv ACL.TYPE_ACCESS_OLD
.It Dv ACL.TYPE_DEFAULT_OLD
.It Dv ACL.TYPE_ACCESS
.It Dv ACL.TYPE_DEFAULT
.It Dv ACL.TYPE_NFS4
.It Dv ACL.EXECUTE
.It Dv ACL.WRITE
.It Dv ACL.READ
.It Dv ACL.PERM_NONE
.It Dv ACL.PERM_BITS
.It Dv ACL.POSIX1E_BITS
.It Dv ACL.READ_DATA
.It Dv ACL.LIST_DIRECTORY
.It Dv ACL.WRITE_DATA
.It Dv ACL.ADD_FILE
.It Dv ACL.APPEND_DATA
.It Dv ACL.ADD_SUBDIRECTORY
.It Dv ACL.READ_NAMED_ATTRS
.It Dv ACL.WRITE_NAMED_ATTRS
.It Dv ACL.DELETE_CHILD
.It Dv ACL.READ_ATTRIBUTES
.It Dv ACL.WRITE_ATTRIBUTES
.It Dv ACL.DELETE
.It Dv ACL.READ_ACL
.It Dv ACL.WRITE_ACL
.It Dv ACL.WRITE_OWNER
.It Dv ACL.SYNCHRONIZE
.It Dv ACL.FULL_SET
.It Dv ACL.MODIFY_SET
.It Dv ACL.READ_SET
.It Dv ACL.WRITE_SET
.It Dv ACL.NFS4_PERM_BITS
.It Dv ACL.FIRST_ENTRY
.It Dv ACL.NEXT_ENTRY
.It Dv ACL.ENTRY_FILE_INHERIT
.It Dv ACL.ENTRY_DIRECTORY_INHERIT
.It Dv ACL.ENTRY_NO_PROPAGATE_INHERIT
.It Dv ACL.ENTRY_INHERIT_ONLY
.It Dv ACL.ENTRY_SUCCESSFUL_ACCESS
.It Dv ACL.ENTRY_FAILED_ACCESS
.It Dv ACL.ENTRY_INHERITED
.It Dv ACL.FLAGS_BITS
.It Dv ACL.UNDEFINED_ID
.It Dv ACL.TEXT_VERBOSE
.It Dv ACL.TEXT_NUMERIC_IDS
.It Dv ACL.TEXT_APPEND_ID
.It Dv ACL.OVERRIDE_MASK
.It Dv ACL.PRESERVE_MASK
.El
.Sh DESCRIPTION
The
.Nm acl
module provides bindings for the libc
.Xr acl 3
POSIX.1e/NFSv4 ACL security API.
.Bl -tag -width XXXX
.It Dv ok, errmsg, errcode = ACL.delete(file[ , type ] )
Wraps
.Xr acl_delete 3 .
.Fa file
is a Lua
.Vt file
object, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
.It Dv ok, errmsg, errcode = ACL.delete_fd(fd[ , type ] )
Wraps
.Xr acl_delete 3 .
.Fa fd
is an
.Vt integer
file descriptor number, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
.It Dv ok, errmsg, errcode = ACL.delete_file(path[ , type ] )
Wraps
.Xr acl_delete 3 .
.Fa path
is a
.Vt string
file path, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
If
.Fa path
is a path to a symlink, the link is followed.
.It Dv ok, errmsg, errcode = ACL.delete_link(path[ , type ] )
Wraps
.Xr acl_delete 3 .
.Fa path
is a
.Vt string
file path, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
If
.Fa path
is a path to a symlink, the link is not followed.
.It Dv extended, errmsg, errcode = ACL.extended_file(path )
Wraps
.Xr acl_extended_file_np 3 .
.It Dv extended, errmsg, errcode = ACL.extended_link(path )
Wraps
.Xr acl_extended_link_np 3 .
.It Dv acl, errmsg, errcode = ACL.from_mode(mode )
Wraps
.Xr acl_from_mode_np 3 .
.Fa mode
is an
.Vt integer .
.It Dv acl, errmsg, errcode = ACL.from_text(text )
Wraps
.Xr acl_from_text 3 .
.It Dv acl, errmsg, errcode = ACL.get(file[ , type ] )
Wraps
.Xr acl_get 3 .
.Fa file
is a Lua
.Vt file
object, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
.It Dv acl, errmsg, errcode = ACL.get_fd(fd[ , type ] )
Wraps
.Xr acl_get 3 .
.Fa file
is an
.Vt integer
file descriptor number, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
.It Dv acl, errmsg, errcode = ACL.get_file(path[ , type ] )
Wraps
.Xr acl_get 3 .
.Fa path
is a
.Vt string
file path, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
If
.Fa path
is a path to a symlink, the link is followed.
.It Dv acl, errmsg, errcode = ACL.get_link(path[ , type ] )
Wraps
.Xr acl_get 3 .
.Fa path
is a
.Vt string
file path, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
If
.Fa path
is a path to a symlink, the link is not followed.
.It Dv acl, errmsg, errcode = ACL.new([count ] )
Wraps
.Xr acl_init 3 .
.It Dv acl1 == acl2
Wraps
.Xr acl_cmp_np 3 .
.It Dv ok, errmsg, errcode = acl:calc_mask( )
Wraps
.Xr acl_calc_mask 3 .
.It Dv entry, errmsg, errcode = acl:create_entry([index ] )
Wraps
.Xr acl_create_entry 3 .
.It Dv ok, errmsg, errcode = acl:delete_entry([entry | index ] )
Wraps
.Xr acl_delete_entry 3 .
.It Dv acl1, errmsg, errcode = acl:dup( )
Wraps
.Xr acl_dup 3 .
.It Dv possible, mode_or_errmsg, errcode = acl:equiv_mode( )
Wraps
.Xr acl_equiv_mode_np 3 .
Returns a
.Vt boolean
if successful and if
.Dv true
also returns the mode as an
.Vt integer .
.It Dv brand, errmsg, errcode = acl:get_brand( )
Wraps
.Xr acl_get_brand_np 3 .
.It Dv entry, errmsg, errcode = acl:get_entry(id )
Wraps
.Xr acl_get_entry 3 .
.It Dv trivial, errmsg, errcode = acl:is_trivial( )
Wraps
.Xr acl_is_trivial_np 3 .
Returns a
.Vt boolean
if successful.
.It Dv ok, errmsg, errcode = acl:set(file[ , type ] )
Wraps
.Xr acl_set 3 .
.Fa file
is a Lua
.Vt file
object, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
.It Dv ok, errmsg, errcode = acl:set_fd(fd[ , type ] )
Wraps
.Xr acl_set 3 .
.Fa fd
is an
.Vt integer
file descriptor number, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
.It Dv ok, errmsg, errcode = acl:set_file(path[ , type ] )
Wraps
.Xr acl_set 3 .
.Fa path
is a
.Vt string
file path, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
If
.Fa path
is a path to a symlink, the link is followed.
.It Dv ok, errmsg, errcode = acl:set_link(path[ , type ] )
Wraps
.Xr acl_set 3 .
.Fa path
is a
.Vt string
file path, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
If
.Fa path
is a path to a symlink, the link is not followed.
.It Dv acl1, errmsg, errcode = acl:strip(recalculate_mask )
Wraps
.Xr acl_strip_np 3 .
.Fa recalculate_mask
is a
.Vt boolean .
.It Dv text, errmsg, errcode = acl:to_text([flags ] )
Wraps
.Xr acl_to_text 3 .
.It Dv valid, errmsg, errcode = acl:valid([file[ , type ] ] )
Wraps
.Xr acl_valid 3 .
.Fa file
is a Lua
.Vt file
object, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
.It Dv valid, errmsg, errcode = acl:valid_fd(fd[ , type ] )
Wraps
.Xr acl_valid 3 .
.Fa fd
is an
.Vt integer
file descriptor number, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
.It Dv valid, errmsg, errcode = acl:valid_file(path[ , type ] )
Wraps
.Xr acl_valid 3 .
.Fa path
is a
.Vt string
file path, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
If
.Fa path
is a path to a symlink, the link is followed.
.It Dv valid, errmsg, errcode = acl:valid_link(path[ , type ] )
Wraps
.Xr acl_valid 3 .
.Fa path
is a
.Vt string
file path, and
.Fa type
is an optional ACL type with the default value
.Dv ACL.TYPE_ACCESS .
If
.Fa path
is a path to a symlink, the link is not followed.
.It Dv ok, errmsg, errcode = entry:copy(src_entry )
Wraps
.Xr acl_copy_entry 3 .
.It Dv flagset, errmsg, errcode = entry:get_flagset( )
Wraps
.Xr acl_get_flagset_np 3 .
.It Dv permset, errmsg, errcode = entry:get_permset( )
Wraps
.Xr acl_get_permset 3 .
.It Dv qualifier, errmsg, errcode = entry:get_qualifier( )
Wraps
.Xr acl_get_qualifier 3 .
.It Dv tag_type, errmsg, errcode = entry:get_tag_type( )
Wraps
.Xr acl_get_tag_type 3 .
.It Dv type, errmsg, errcode = entry:get_type( )
Wraps
.Xr acl_get_entry_type_np 3 .
.It Dv ok, errmsg, errcode = entry:set_flagset(flagset )
Wraps
.Xr acl_set_flagset_np 3 .
.It Dv ok, errmsg, errcode = entry:set_permset(permset )
Wraps
.Xr acl_set_permset 3 .
.It Dv ok, errmsg, errcode = entry:set_qualifier(qualifier )
Wraps
.Xr acl_set_qualifier 3 .
.It Dv ok, errmsg, errcode = entry:set_tag_type(tag_type )
Wraps
.Xr acl_set_tag_type 3 .
.It Dv ok, errmsg, errcode = entry:set_type(type )
Wraps
.Xr acl_set_entry_type_np 3 .
.It Dv ok, errmsg, errcode = flagset:add(flag )
Wraps
.Xr acl_add_flag_np 3 .
.It Dv ok, errmsg, errcode = flagset:clear( )
Wraps
.Xr acl_clear_flags_np 3 .
.It Dv ok, errmsg, errcode = flagset:delete(flag )
Wraps
.Xr acl_delete_flag_np 3 .
.It Dv set, errmsg, errcode = flagset:get(flag )
Wraps
.Xr acl_get_flag_np 3 .
.It Dv ok, errmsg, errcode = permset:add(perm )
Wraps
.Xr acl_add_perm 3 .
.It Dv ok, errmsg, errcode = permset:clear( )
Wraps
.Xr acl_clear_perms 3 .
.It Dv ok, errmsg, errcode = permset:delete(flag )
Wraps
.Xr acl_delete_perm 3 .
.It Dv set, errmsg, errcode = permset:get(perm )
Wraps
.Xr acl_get_perm_np 3 .
.El
.Sh EXAMPLES
Show the equivalent ACL for a file mode:
.Bd -literal -offset indent
local ACL = require('acl')

local mode = tonumber("755", 8) -- octal 755
print(ACL.from_mode(mode):to_text())
.Ed
.Sh SEE ALSO
.Xr getfacl 1 ,
.Xr setfacl 1 ,
.Xr acl 3 ,
.Xr acl 9
.Sh AUTHORS
.An Ryan Moeller
